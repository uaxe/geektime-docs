你好，我是 Tyler。

在上节课中我们学习了 AIGC 系统策略建模的方法。接下来我们会深入学习AIGC系统各模块的知识。我们先从提示语工程开始学起。

之前我也说过，提示引擎在一定程度上就是“智能体的本体”，所以它的重要性不言而喻。拿建筑行业做比方，提示引擎（prompt engine）是一个功能完备、拎包入住的成品房，而提示语工程（prompt engineering）就是搭建这个房子的设计图纸和施工手册。

为了让你全面系统地学习这部分知识，我安排了四节课做讲解。今天我们的学习重点是熟悉提示语工程的主要概念和设计方法。

## 提示语工程概念

上节课你已经学习了提示语引擎是专门服务于生成式 AI 模型的系统模块，它需要具备各类知识表达和知识检索的能力，识别用户意图、选择检索结果，并且进行有效的信息压缩。而这些任务都需要精心设计的提示语工程来完成。

而在学习提示语工程设计之前，我们需要搞清楚提示语工程中的主要概念。

### 上下文学习（In-Context Learning，ICL）

首先，让我们来谈谈上下文学习的概念，这是提示语工程诞生的基础。在GPT-3的 [那节课](https://time.geekbang.org/column/article/700557) 里，我们学习到了OpenAI提出的一个更新的理念，即“上下文学习（In-Context Learning）”。这个能力允许我们在提示语中提供示例样本，以帮助模型理解要解决的任务的特点。

这种不需要模型微调，直接将知识通过提示词注入模型的方法也引出了全新的“少样本学习（Few-Shot Learning）”的概念。

与传统的模型微调中的“少样本学习”不同，GPT-3提出的少样本学习允许下游用户直接通过提示词（prompt）将任务示例样本输入到模型中，从而使模型在提示语中学习新样本的模式和规律。

根据提供的示例样本数量，提示语工程可以分为“零样本学习（Zero-Shot Learning）”和“少样本学习（Few-Shot Learning）”。

零样本学习就是直接将模型需要处理的任务，通过提示语提供给模型，并要求模型输出结果。而少样本学习则会为模型提供例子，具体就是一组在目标任务上的高质量示例，通常每个示例都包括一组目标的输入和输出。

在AIGC系统中，如果你的提示引擎直接将用户输入的问题传递给LLM，那用的就是 Zero-Shot 的处理方法。最早期的ChatGPT采用了这种方法，它会直接将用户的输入内容“透传”给大型语言模型。

不过在早期的这种“简陋”的使用条件下，一些对提示语工程有所了解的用户也会在问题前为大语言模型提供一些示例，手动把它变成 Few-Shot 提示语。

然而，这时用户只能基于自己的使用经验来选择更合适的提示词，但这种靠猜测试探的方式升高了大语言模型的使用门槛。

因此，大模型系统会根据不同用户的使用记录，自行判断哪类提示词对自家模型更友好。在提示与长度限制相对宽松的情况下，系统还会自动使用Few-Shot的形式帮助用户使用更加友好的提示词来优化提示语质量。

我们稍微总结一下，提示语工程的核心目标是，基于ICL的特点为LLM选择适当的Few-Shot示例样本。

### 指令微调

指令微调是我们之前课程里学习的一项技术，它与ICL不同，是通过模型微调将用户在平台中的历史问答的信息，直接“固化”到模型的参数中的一种方法。

然而，从提示语工程的角度来看，指令微调更多是让模型理解该如何与外部世界对话。狭义上，这个外部世界是用户的对话输入。但从广义上讲，经过提示语引擎加工后的数据，也是外部世界的对话内容。因此，在对模型进行指令微调时，我们需要考虑到用户问答输入的分布以及提示语引擎处理后数据内容的分布的区别，这可能会引入新的问题。

由于指令微调不是这节课的重点，我会在大模型训练那节课带你详细学习这个内容。

## 提示语工程设计

理解了前面的概念，你应该已经意识到了，提示语工程最重要的是后面这两个问题。

1. 为模型提供外部知识，也就是通过示例样本来进行少样本学习（Few-Shot Learning）。
2. 让模型理解指令任务，通过提示语策略，帮助模型解决复杂问题。

我们先来讨论第一个问题，那就是如何为模型提供有效的示例样本。在术语上的说法则是优选（Selecting）。

### 优选（Selecting）

为模型优选示例样本的过程，其实就是围绕着用户输入的问题，为模型收集高质量数据的过程。你可以试着回想一下，在AIRC系统中你是如何收集高质量数据的呢？

没错，是通过召回和排序完成的，其中召回过程需要使用向量引擎，内容标签倒排索引和知识图谱等知识表达和知识检索方法。

其实在提示引擎中我们第一步要做的工作就是围绕用户的需求，去检索这些最重要的外部数据。这个检索和你之前学过的AIRC系统中的知识是一模一样的。

你同样需要将最优质的内容排在前面，因为大模型所能接受的 prompt 是有限的，你只能在海量的内容中优选最重要的内容，来作为提示词的一部分。具体怎么排序我们接着往下看。

### 排序（Ordering）

在选择最合适的提示样本后，我们需要进一步对其进行二次加工，这个加工过程是AIGC系统独有的“重排”模块，用于优化提示的内容。

因为业界的实践表明，在某些测试中，不同排序的示例可能导致生成内容的质量大幅波动。因此，除了示例样本的选取之外，示例的排序也会影响提示工程的有效性。

目前，主要有一种常见的工业界使用的排序策略，也是最低成本的策略，那就是基于示例质量的排序，这个方法非常直接，只需要将质量较高的示例样本排在后面，以靠近问题输入的位置。除此之外，还有一些相对复杂的基于熵的排序方法，这个我们将在下节课进行学习。

### 可信AI（Trustworthy AI）

之前说过，提示语引擎其实一定程度上就是智能体的“本体”。所以LLM的输入，也就是提示词，以及输出也就是生成内容都需要由提示语引擎来负责。因此，现在工业界在AIGC系统的链路就是：检索 -> 生成 -> 检索的形态。你可能会问了，检索到生成的这个过程我倒是理解，可是为什么生成后面还会再加一个检索呢？

很好的问题，这是因为两次检索的目标是不同的。第一次检索的输入是用户问题，目的是为大语言模型提供外部记忆；而第二次检索的输入则是生成内容，目的是为生成的内容提供引用信息，增加生成内容的可信度，此外，我们还可以通过这次检索，来优选生成模型输出的多个结果。

### 推理步骤（Reasoning Steps）

现在，你已经知道了该如何为大语言模型提供有效的示例样本。接下来，我们再来聊聊怎样通过提示语策略，帮助模型解决复杂问题。我们将用一些思维链方法帮助模型把大事化小。

首先，让我们回顾一下思维链（Chain-of-Thought，CoT）的概念。CoT是一种用于引导大语言模型进行推理的方法。CoT通过提示词指示模型，生成一系列简短的句子来给出推理步骤。

在 [第16节课](https://time.geekbang.org/column/article/701454) 中我们学习过，工业界在实践中发现，经过代码语料训练过的LLM具有更强的 CoT 能力。在 [第17节课](https://time.geekbang.org/column/article/701952)，也就是“涌现”原理的那节课里我们也提过，CoT 的优势在复杂的推理任务更明显，在使用大参数模型（比如 50B以上的模型）时，这个优势则更明显。

CoT 提示可以约束大语言模型理解和遵循推理逻辑，从而提高推理任务的准确性。虽然 CoT 可以用一些动态的步骤生成答案，但是还是存在一些局限性。这就催生出了很多方法来优化 CoT 的过程，比如我们下节课马上要学习的自一致采样（Self-Consistency Sampling）。

## 总结

好的，我们来做个总结吧。

今天，我们一起深入学习了 ICL 的核心理念，还有由 ICL 能力而衍生出的、提示语工程的众多特性。你不仅学到了怎么利用已经学习过的 AIRC 知识来优选示例样本，还学习了一些对示例样本排序的新方法。

这节课的重点就是如何提升大模型的回复质量。首先我们要构建一个基于二次检索的记忆增强和可信AI策略。其次，就是利用思维链的能力，通过推理策略来协助模型解决复杂问题。

![](https://static001.geekbang.org/resource/image/d4/a9/d48452e6ffb86cf0f8c22e2730d9c8a9.png?wh=1906x778)

提示语工程这几节课的内容高度相关，所以希望你能好好学习消化今天学到的内容。下一节课，我们将会继续深入学习提示引擎的相关能力，敬请期待！

## 思考题

很多人认为提示语工程只是自说自话的试错游戏，你觉得他说的对吗？给出你认为正确或错误的原因。

恭喜完成我们第 19 次打卡学习，期待你在留言区和我交流互动。如果你觉得有收获，也欢迎你分享给你身边的朋友，邀 TA 一起讨论。