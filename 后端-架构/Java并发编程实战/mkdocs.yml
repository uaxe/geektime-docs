site_name: Java并发编程实战

theme:
  name: material

  palette:
    # Palette toggle for light mode
    - media: "(prefers-color-scheme: light)"
      scheme: default
      toggle:
        icon: material/brightness-4
        name: Switch to dark mode

    # Palette toggle for dark mode
    - media: "(prefers-color-scheme: dark)"
      scheme: slate
      toggle:
        icon: material/brightness-7
        name: Switch to light mode

  features:
    - navigation.footer
    - content.action.edit
    - navigation.sections
    - content.code.copy

  icon:
    edit: material/pencil
    logo: material/console-line

extra:
  homepage:
  version:
    provider: mike

copyright: Copyright © 2024-Present zkep
repo_url: https://github.com/zkep/mygeektime

markdown_extensions:
  - attr_list
  - md_in_html
  - pymdownx.highlight:
      anchor_linenums: true
  - pymdownx.inlinehilite
  - pymdownx.snippets
  - pymdownx.superfences

nav:
   - Java并发编程实战.md
  
   - 开篇词 - 你为什么需要学习并发编程？.md
  
   - 学习攻略 - 如何才能学好并发编程？.md
  
   - 01 - 可见性、原子性和有序性问题：并发编程Bug的源头.md
  
   - 02 - Java内存模型：看Java如何解决可见性和有序性问题.md
  
   - 03 - 互斥锁（上）：解决原子性问题.md
  
   - 04 - 互斥锁（下）：如何用一把锁保护多个资源？.md
  
   - 05 - 一不小心就死锁了，怎么办？.md
  
   - 06 - 用“等待-通知”机制优化循环等待.md
  
   - 07 - 安全性、活跃性以及性能问题.md
  
   - 08 - 管程：并发编程的万能钥匙.md
  
   - 09 - Java线程（上）：Java线程的生命周期.md
  
   - 10 - Java线程（中）：创建多少线程才是合适的？.md
  
   - 11 - Java线程（下）：为什么局部变量是线程安全的？.md
  
   - 12 - 如何用面向对象思想写好并发程序？.md
  
   - 13 - 理论基础模块热点问题答疑.md
  
   - 14 - Lock和Condition（上）：隐藏在并发包中的管程.md
  
   - 15 - Lock和Condition（下）：Dubbo如何用管程实现异步转同步？.md
  
   - 16 - Semaphore：如何快速实现一个限流器？.md
  
   - 17 - ReadWriteLock：如何快速实现一个完备的缓存？.md
  
   - 18 - StampedLock：有没有比读写锁更快的锁？.md
  
   - 19 - CountDownLatch和CyclicBarrier：如何让多线程步调一致？.md
  
   - 20 - 并发容器：都有哪些“坑”需要我们填？.md
  
   - 21 - 原子类：无锁工具类的典范.md
  
   - 22 - Executor与线程池：如何创建正确的线程池？.md
  
   - 23 - Future：如何用多线程实现最优的“烧水泡茶”程序？.md
  
   - 24 - CompletableFuture：异步编程没那么难.md
  
   - 25 - CompletionService：如何批量执行异步任务？.md
  
   - 26 - Fork-Join：单机版的MapReduce.md
  
   - 27 - 并发工具类模块热点问题答疑.md
  
   - 28 - Immutability模式：如何利用不变性解决并发问题？.md
  
   - 29 - Copy-on-Write模式：不是延时策略的COW.md
  
   - 30 - 线程本地存储模式：没有共享，就没有伤害.md
  
   - 31 - Guarded Suspension模式：等待唤醒机制的规范实现.md
  
   - 32 - Balking模式：再谈线程安全的单例模式.md
  
   - 33 - Thread-Per-Message模式：最简单实用的分工方法.md
  
   - 34 - Worker Thread模式：如何避免重复创建线程？.md
  
   - 35 - 两阶段终止模式：如何优雅地终止线程？.md
  
   - 36 - 生产者-消费者模式：用流水线思想提高效率.md
  
   - 37 - 设计模式模块热点问题答疑.md
  
   - 38 - 案例分析（一）：高性能限流器Guava RateLimiter.md
  
   - 39 - 案例分析（二）：高性能网络应用框架Netty.md
  
   - 40 - 案例分析（三）：高性能队列Disruptor.md
  
   - 41 - 案例分析（四）：高性能数据库连接池HiKariCP.md
  
   - 42 - Actor模型：面向对象原生的并发模型.md
  
   - 43 - 软件事务内存：借鉴数据库的并发经验.md
  
   - 44 - 协程：更轻量级的线程.md
  
   - 45 - CSP模型：Golang的主力队员.md
  
   - 结束语 - 十年之后，初心依旧.md
  
   - 结课测试 - 这些Java并发编程实战的知识你都掌握了吗？.md
  
   - 用户来信 - 真好，面试考到这些并发编程，我都答对了！.md
  
   - 3 个用户来信 - 打开一个新的并发世界.md
  